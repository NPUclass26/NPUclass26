## 第二周：数据结构

### 2.1.1 单链表

算法竞赛中的链表一般使用数组进行模拟。用来存树和图，注意一下头指针以及插入节点时更新各个数据的顺序即可

代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
int e[maxn],ne[maxn],idx,head;
void init()
{
	head=-1;idx=0;
}
void add_to_head(int x)
{
	e[idx]=x;
	ne[idx]=head;
	//一定记住先让链表后面的节点链接新加入的节点，再让前面的节点链接
	//不然后面的节点就丢失了 
	head=idx++;
}
void remove(int k)
{
	ne[k]=ne[ne[k]];
}
void insert(int k,int x)
{
	//此处同理注意顺序 
	e[idx]=x;ne[idx]=ne[k];ne[k]=idx++;
}
int main()
{
	int m;
	init();
	scanf("%d",&m);
	while(m--)
	{
		char opt;int k,x;
		scanf("\n%c",&opt);
		if(opt=='H')
		{
			scanf("%d",&x);
			add_to_head(x);
		}
		if(opt=='D')
		{
			scanf("%d",&k);
			if(!k) head=ne[head];
			else remove(k-1);
		}
		if(opt=='I')
		{
			scanf("%d%d",&k,&x);
			insert(k-1,x);
		}
	}
	for(int i=head;i!=-1;i=ne[i]) printf("%d ",e[i]);
	putchar('\n');
	return 0;
}
```

### 2.1.2 双链表

需要开一个头节点和一个尾结点，对比单链表其实就是多了一个前驱数组，其他没什么区别。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
int e[maxn],l[maxn],r[maxn],idx,head,tail;
void init()
{
	r[0]=1;l[1]=0;
	idx=2;
}
void insert(int k,int x)
{
	e[idx]=x;
	l[idx]=k;r[idx]=r[k];
	l[r[k]]=idx;r[k]=idx++;
}
void remove(int k)
{
	r[l[k]]=r[k];
	l[r[k]]=l[k];
}
int main()
{
	int m;
	init();
	
	scanf("%d",&m);
	
	while(m--)
	{
		char opt[5]={0};int k,x;
		scanf("%s",opt);
		if(!strcmp(opt,"L"))
		{
			scanf("%d",&x);
			insert(0,x);
		}
		if(!strcmp(opt,"R"))
		{
			scanf("%d",&x);
			insert(l[1],x);
		}
		if(!strcmp(opt,"IL"))
		{
			scanf("%d%d",&k,&x);
			insert(l[k+1],x);
		}
		if(!strcmp(opt,"IR"))
		{
			scanf("%d%d",&k,&x);
			insert(k+1,x);
		}
		if(!strcmp(opt,"D"))
		{
			scanf("%d",&k);
			remove(k+1);
		}
	}
	for(int i=r[0];i!=1;i=r[i]) printf("%d ",e[i]);
	putchar('\n');
	return 0;
}
```
### 2.2.1栈

对于栈和队列而言，重要的是对它的理解，在具体题目中的考察，维护深搜和广搜之类的。代码实现的话，STL其实就够了
```cpp
stack<类型名> s;
s.push(u);//向栈中插入u 
u=s.top();//获得栈顶元素 
s.pop();//栈顶元素出栈 
s.empty();//判断栈是否为空 
s.size()//返回栈的大小 
```
用数组模拟的话就是下面这样

```cpp
// tt表示栈顶
int stk[N], tt = 0;
// 向栈顶插入一个数
stk[ ++ tt] = x;
// 从栈顶弹出一个数
tt -- ;
// 栈顶的值
stk[tt];
// 判断栈是否为空
if (tt > 0)
{
}
```
### 2.2.2队列
STL如下
```cpp
queue<类型名> q;
q.push(u) //向队列尾插入u
q.pop() //弹出队头
q.front() //访问队头元素
q.back() //访问队尾元素
q.empty() //判断是否为空
q.size()//返回队列大小 
```
普通队列：

```c++
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt)
{

}
```

循环队列：

```cpp
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}
```
### 2.2.3 单调栈

和单调队列一样的数据结构，但只用到了单调队列的一端
```cpp
#include<bits/stdc++.h>
using namespace std;
stack<int> s;
int main()
{
    int n,x;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x);
        while(!s.empty()&&x<=s.top()) s.pop();
        if(s.empty()) printf("-1 ");
        else printf("%d ",s.top());
        s.push(x);
    }
    return 0;
}
```
### 2.2.4 单调队列
单调队列本质上是一种双端队列，队列当中保持单调性。加入新元素时会从后一直弹出元素，直到加进去的那个数能使得整个队列仍然单调为止。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
int ans1[maxn],ans2[maxn],a[maxn],n,k;
deque<int> q;
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	//处理定长区间最小值 
	ans1[1]=a[1];
	q.push_back(1);
	for(int i=2;i<=n;i++)
	{
		while(!q.empty()&&a[q.back()]>a[i]) q.pop_back();
		q.push_back(i);
		while(!q.empty()&&q.front()<i-k+1) q.pop_front();
		ans1[i]=a[q.front()];
	}
	//处理定长区间最大值
	q.clear();
	ans2[1]=a[1];
	q.push_back(1);
	for(int i=2;i<=n;i++)
	{
		while(!q.empty()&&a[q.back()]<a[i]) q.pop_back();
		q.push_back(i);
		while(!q.empty()&&q.front()<i-k+1) q.pop_front();
		ans2[i]=a[q.front()];
	}
	for(int i=k;i<=n;i++) printf("%d ",ans1[i]);putchar('\n');
	for(int i=k;i<=n;i++) printf("%d ",ans2[i]);putchar('\n');
	return 0;
}
```

#### 2.3.2 trie树

支持insert和query两种操作，维护一个集合

insert 向集合中插入一个字符串

query 询问集合中有多少个这样的字符串



数据结构类似一棵树，树的每条链都由插入的字符串组成

访问的时候开一个指针变量就可以了

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+5;
char str[maxn];
int son[maxn][26],cnt[maxn],idx;
//son[p][u]表示节点p是否有u这个子节点
//cnt[p]表示以这个节点结尾的单词的数目
void insert(char str[])
{
	int p=0;//p是指向树节点的指针
	for(int i=0;str[i];i++)
	{
		int u=str[i]-'a';
		if(!son[p][u]) son[p][u]=++idx;
		p=son[p][u];
	}
	cnt[p]++;
}
int query(char str[])
{
	int p=0;
	for(int i=0;str[i];i++)
	{
		int u=str[i]-'a';
		if(!son[p][u]) return 0;
		p=son[p][u];
	}
	return cnt[p];
}
int main()
{
	int n;
	scanf("%d",&n);
	while(n--)
	{
		char opt[2];
		scanf("%s%s",opt,str);
		if(opt[0]=='I') insert(str);
		else printf("%d\n",query(str));
	}
	return 0;
}
```

