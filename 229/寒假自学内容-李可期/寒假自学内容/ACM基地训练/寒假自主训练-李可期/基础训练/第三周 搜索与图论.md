## 3.1 DFS与BFS

DFS用一般系统栈帧（递归）来实现，BFS一般使用队列实现

比较重要的就是如何设计状态了，搜索的过程其实就是由最初状态一步一步走到最终状态的过程

不一样的题目有不一样的状态，我们就需要把问题用几个数据简单而又正确地描述出来。

### 3.1.1 全排列

状态就是当前搜到第几个数了，很简单

代码如下

```cpp
#include<cstdio>
using namespace std;
int n,ans[10];
bool used[10];
void print()
{
    for(int i=1;i<=n;i++)
        printf("%d ",ans[i]);
    printf("\n");
}
void dfs(int t)
{
    if(t>n)
    {
        print();
        return;
    }
    for(int i=1;i<=n;i++)
        if(!used[i])
        {
            ans[t]=i;
            used[i]=true;//将i标记为已经使用过
            dfs(t+1);
            used[i]=false;//做完了这一层，回溯发生之前的现场，将描述状态的全局变量复原
        }
}
int main()
{
    scanf("%d",&n);
    dfs(1);
    return 0;
}
```

### 3.1.2 n皇后

也是一样地深搜，不过被影响的状态有对角线，反对角线以及行和列，开全局变量维护它们有没有被占用。

一行一行地放，放完n行肯定就是最终的结果了

代码如下

```cpp
#include<cstdio>
using namespace std;
const int maxn=50;
bool h[maxn],dj[maxn],fdj[maxn];
int n,ans,a[maxn];
void does()
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
			if(j==a[i]) printf("Q");
			else printf(".");
		printf("\n");
	}
	printf("\n");
}
void print()
{
	ans++;does();
	return;
}
void dfs(int i)
{
	for(int j=1;j<=n;j++)
	{
		if(!h[j]&&!dj[i+j]&&!fdj[i-j+7])
		{
			a[i]=j;
			h[j]=true;dj[i+j]=true;
			fdj[i-j+7]=true;
			if(i==n) print();
			else dfs(i+1);
			h[j]=false;dj[i+j]=false;
			fdj[i-j+7]=false;
		}
	}
}
int main()
{
	scanf("%d",&n);
	dfs(1);
	return 0;
}
```

### 3.2.1 走迷宫

走迷宫，但是求最短步数。BFS的一个特性就是逐层扩展，因此，在哪一层扩展到了终点，那层的序数就是最短的步数，使用队列描述状态。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=105;
bool vis[maxn][maxn];
int dis[maxn][maxn],n,m;
struct node
{
    int x;int y;
};
//结构体描述状态，描述状态需要几个变量就开几个域
queue<node> q;
void bfs()
{
    q.push((node){1,1});
    while(!q.empty())
    {
        node temp=q.front();q.pop();
        int x=temp.x,y=temp.y;
        if(x<=0||x>n||y>m||y<=0) continue;
        if(!vis[x+1][y])
        {
            vis[x+1][y]=true;
            dis[x+1][y]=dis[x][y]+1;
            q.push((node){x+1,y});
        }
        if(!vis[x][y-1])
        {
            vis[x][y-1]=true;
            dis[x][y-1]=dis[x][y]+1;
            q.push((node){x,y-1});
        }
        if(!vis[x][y+1])
        {
            vis[x][y+1]=true;
            dis[x][y+1]=dis[x][y]+1;
            q.push((node){x,y+1});
        }
        if(!vis[x-1][y])
        {
            vis[x-1][y]=true;
            dis[x-1][y]=dis[x][y]+1;
            q.push((node){x-1,y});
        }
    }
}
int main()
{
    int x;
    scanf("%d%d",&n,&m);
    memset(vis,false,sizeof vis);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&x);
            if(x) vis[i][j]=true;
        }
    bfs();
    printf("%d\n",dis[n][m]);
    return 0;
}
```

### 3.2.2 八数码

没看y总视频自己写了一遍，是个很要技巧的广搜，用个哈希压缩了一下

```cpp
#include<cstdio>
#include<cstring>
#include<set>
using namespace std;

typedef int State[9];
const int MAXSTATE=1000000;
State st[MAXSTATE],goal={1,2,3,8,0,4,7,6,5};
int dist[MAXSTATE];

set<int> vis;
void init_lookup_table() { vis.clear(); }
int try_to_insert(int s)
{
    int v=0;
    for(int i=0;i<9;i++) v=v*10+st[s][i];
    if(vis.count(v)) return 0;
    vis.insert(v);
    return 1;
}

const int dx[]={-1,1,0,0};
const int dy[]={0,0,-1,1};
int bfs()
{
    init_lookup_table();
    int front=1,rear=2;
    while(front<rear)
    {
        State& s=st[front];
        if(memcmp(goal,s,sizeof(s))==0) return front;
        int z;
        for(z=0;z<9;z++) if(!s[z]) break;
        int x=z/3,y=z%3;
        for(int d=0;d<4;d++)
        {
            int newx=x+dx[d];
            int newy=y+dy[d];
            int newz=newx*3+newy;
            if(newx>=0 && newx<3 && newy>=0 && newy<3)
            {
                State& t=st[rear];
                memcpy(&t,&s,sizeof(s));
                t[newz]=s[z];
                t[z]=s[newz];
                dist[rear]=dist[front]+1;
                if(try_to_insert(rear)) rear++;
            }
        }
        front++;
    }
    return 0;
}

int main()
{
    char s[15];
    scanf("%s",s);
    for(int i=0;i<9;i++)
        st[1][i]=s[i]-'0';
    int ans = bfs();
    printf("%d\n", dist[ans]);
    return 0;
}


```

### 3.2.2.1 树的重心

$dfs$的途中记录数据

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=5e5+5;
struct Edge
{
    int next;int to;
}edge[maxn];
int head[maxn];
int ans=maxn,tot,n;
bool vis[maxn];
void addedge(int from,int to)
{
    edge[++tot].next=head[from];
    edge[tot].to=to;
    head[from]=tot;
}
int dfs(int u)
{
    vis[u]=true;
    int sum=1,res=0;
    //printf("u=%d\n",u);
    for(int i=head[u];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(!vis[v])
        {
            int s=dfs(v);
            sum+=s;
            res=max(res,s);
        }
    }
    res=max(res,n-sum);
    ans=min(ans,res);
    return sum;
}
int main()
{
    int x,y;
    scanf("%d",&n);
    for(int i=1;i<=n-1;i++)
    {
        scanf("%d%d",&x,&y);
        addedge(x,y);
        addedge(y,x);
    }
    dfs(1);
    printf("%d\n",ans);
    return 0;
}
```

### 3.2.2.2 图中点的层次

其实就是走迷宫的题的状态把坐标换成了点的编号捏

```cpp
#include<cstdio>
#include<queue>
using namespace std;
const int maxn=100005;
const int maxm=500001;
const int inf=0x3fffffff;
struct node
{
	int next;
	int to;
	int dis;
}edge[maxm];
int head[maxm],dis[maxn],vis[maxn],n,m,s,tot;
queue<int> q;
void addedge(int from,int to,int dis)
{
	edge[++tot].next=head[from];
	edge[tot].to=to;
	edge[tot].dis=dis;
	head[from]=tot;
}
void spfa()
{
	for(int i=1;i<=n;i++)
	{
		dis[i]=inf;
		vis[i]=0;
	}
	dis[s]=0;vis[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(dis[u]+edge[i].dis<dis[v])
			{
				dis[v]=dis[u]+edge[i].dis;
				if(!vis[v]) vis[v]=1;
				q.push(v);
			}
		}
	}
}
int main()
{
	int x,y,z;
	scanf("%d%d",&n,&m);
	s=1;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		if(x==y) continue;
		z=1;
		addedge(x,y,z);
	}
	spfa();
	if(!vis[n]) printf("-1\n");
	else printf("%d\n",dis[n]);
	return 0;
}
```

### 3.2.3 拓扑排序

个人认为拓扑排序除了可以用$o(n)$时间判断有向图有没有环之外，剩下的用处就是DP了。

写了道洛谷P1685 采花

很明显的图上DP，因为题目保证不构成环

设$cnt[u]$表示到达点$u$的次数，$dp[u]$表示到$u$的总路径长度

则显然有$cnt[u]=\sum_{u->v}cnt[v]$和$dp[u]=\sum_{u-v}dp[v]+cnt[v]*w$

如何确定转移顺序呢，在AOV网中，自然是使用拓扑排序啦，代码如下

```cpp
#include<cstdio>
#include<queue> 
#include<string>
#include<algorithm>
#define il inline
using namespace std;
const int maxn=1e5+5;
const int p=10000;
int n,m,s,t,val,tot,ans;
int ru[maxn],cnt[maxn],dp[maxn],head[maxn];
struct node
{
	int next;
	int to;
	int dis;
}edge[maxn];
queue<int> q;
il int read()
{
	int num=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		num=num*10+ch-'0';
		ch=getchar();
	}
	return num*f;
}
il void addedge(int from,int to,int dis)
{
	edge[++tot].next=head[from];
	edge[tot].to=to;
	edge[tot].dis=dis;
	head[from]=tot;
}
il void topsort()
{
	q.push(s);cnt[s]=1;
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			dp[v]=(dp[v]+(dp[u]+edge[i].dis*cnt[u])%p)%p;
			cnt[v]=(cnt[v]+cnt[u])%p;
			ru[v]--;
			if(!ru[v]) q.push(v);
		}
	}
}
int main()
{
	int x,y,z;
	n=read();m=read();s=read();t=read();val=read();
	for(int i=1;i<=m;i++)
	{
		x=read();y=read();z=read();
		ru[y]++;
		addedge(x,y,z);
	}
	topsort();
	ans=(dp[t]+(cnt[t]-1)*val)%p;
	printf("%d\n",ans);
	return 0;
}
```

### 3.3.1 dijkstra算法

dijkstra算法结合了贪心和DP的思想，算法流程，简述一下就是

1、将点划分为两个集合，蓝点表示已经更新过最短路径的，白点表示未更新过最短路径的。

2、利用蓝点计算到白点的距离

3、每次从白点集合中取出一个距离源点最短的，加入蓝点集合，并且更新源点到其它白点的距离

4、重复3、4，直到所有白点变成蓝点

可以使用堆优化的点就在于，每次从白点集合中，取出一个距离源点最短的，只需要用一个小根堆维护即可。

代码如下

```cpp
#include<bits/stdc++.h>
#define il inline
using namespace std;
const int maxn=2e5+5;
const int inf=0x3fffffff;
struct Edge
{
	int next;int to;int dis;
}edge[maxn];
struct node
{
	int u;//点的编号
	int val;//连向这个点的边权 
}; 
int head[maxn],dis[maxn];
int n,m,tot;
il int read()
{
	register int num=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		num=num*10+ch-'0';
		ch=getchar();
	}
	return num*f;
}
il void addedge(int from,int to,int dis)
{
	edge[++tot].next=head[from];
	edge[tot].to=to;
	edge[tot].dis=dis;
	head[from]=tot;
}
priority_queue<node> q;
bool operator < (const node &a,const node &b)
{
	return a.val>b.val;
}
void dijkstra()
{
	for(int i=1;i<=n;i++) dis[i]=inf;
	q.push((node){1,0}),dis[1]=0;
	while(!q.empty())
	{
		node temp=q.top();q.pop();
		int u=temp.u,d=temp.val;
		if(dis[u]!=d) continue;
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(dis[u]+edge[i].dis<dis[v])
			{
				dis[v]=dis[u]+edge[i].dis;
				q.push((node){v,dis[v]});
			}
		}
	}
}
int main()
{
	int x,y,z;
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		x=read();y=read();z=read();
		if(x==y) continue;
		addedge(x,y,z);
	}
	dijkstra();
	if(dis[n]==inf) printf("-1\n");
    else printf("%d\n",dis[n]);
	return 0;
}
```

### 3.3.3 Bellman-Ford算法

原理十分简单，直接就是两层循环,内层循环所有边,外层循环就是循环所有边的次数

限制外层循环的次数，其实就等价于，走不超过$k$条边的最短路

代码如下

```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int N = 510, M = 10010;
struct Edge 
{
    int a;int b;int w;
}e[M];
int dist[N],back[N];
int n,m,k;
void bellman_ford() 
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    for(int i=0;i<k;i++)
	{
        memcpy(back,dist,sizeof dist);
        for (int j=0;j<m;j++)
		{
            int a=e[j].a,b=e[j].b,w=e[j].w;
            dist[b]=min(dist[b],back[a]+w);
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=0;i<m;i++) 
	{
        int a,b,w;
        scanf("%d%d%d",&a,&b,&w);
        e[i]={a,b,w};
    }
    bellman_ford();
    if(dist[n]>0x3f3f3f3f/2) puts("impossible");
    else printf("%d",dist[n]);
    return 0;
}
```

### 3.3.4 SPFA 求最短路

加了个队列优化，如果开一个$cnt[u]$限制$u$入队的次数的话，其实也可以做到像$bellmanford$算法那样

求不超过$k$条边的最短路

代码如下，长得跟广搜像极了

```cpp
#include<cstdio>
#include<queue>
using namespace std;
const int maxn=100005;
const int maxm=500001;
const int inf=0x3fffffff;
struct node
{
	int next;
	int to;
	int dis;
}edge[maxm];
int head[maxm],dis[maxn],vis[maxn],n,m,s,tot;
queue<int> q;
void addedge(int from,int to,int dis)
{
	edge[++tot].next=head[from];
	edge[tot].to=to;
	edge[tot].dis=dis;
	head[from]=tot;
}
void spfa()
{
	for(int i=1;i<=n;i++)
	{
		dis[i]=inf;
		vis[i]=0;
	}
	dis[s]=0;vis[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();vis[u]=0;
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(dis[u]+edge[i].dis<dis[v])
			{
				dis[v]=dis[u]+edge[i].dis;
				if(!vis[v])
				{
				    vis[v]=1;
				    q.push(v);
				}
			}
		}
	}
}
int main()
{
	int x,y,z;
	scanf("%d%d",&n,&m);s=1;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		addedge(x,y,z);
	}
	spfa();
	if(dis[n]>inf/2) printf("impossible\n");
	else printf("%d\n",dis[n]);
	return 0;
}
```

### 3.3.5 spfa判断图中是否存在负环

原理同$bellmanford$算法

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cmath>
#include <cstring>
#include <cstdlib>
#define ll long long
#define maxn 500010
#define INF 0x3fffffff

using namespace std;

int n,m;
int dis[maxn],vis[maxn],num,cnt,s;
int sum[maxn];
int head[maxn];
struct Edge
{
    int next;
    int to;
    int w;
}edge[maxn];

 void add(int u,int v,int val)
{
    edge[++cnt].next=head[u];
    edge[cnt].to=v;
    edge[cnt].w=val;
    head[u]=cnt;
}

bool spfa()
{
	queue<int> q;
    while(!q.empty()) q.pop();
    for(int i=1;i<=n;i++)
    {
        dis[i]=INF;
        vis[i]=0;
    }
    q.push(s);dis[s]=0;vis[s]=1;
    while(!q.empty())
    {
        int u=q.front();q.pop();vis[u]=0;
        //if(sum[u]>=n)  return true;
        for(int i=head[u];i;i=edge[i].next)
        {
            int v=edge[i].to;
            if(dis[v]>dis[u]+edge[i].w)
            {
                dis[v]=dis[u]+edge[i].w;
                if(!vis[v])
                {
                    vis[v]=1;
                    q.push(v);
                    sum[v]++;
                    if(sum[v]>=n) return true;
                }
            }
        }
    }
    return false;
}

int main()
{
    int x,y,z;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        if(x==y)
        {
            if(z<0)
            {
                printf("Yes\n");
                return 0;
            }
            else continue;
        }
        add(x,y,z);
    }
    for(s=1;s<=n;s++)
    	if(spfa())
    	{
    		printf("Yes\n");
    		return 0;
		}
	printf("No\n");
    return 0;
}
```

### 3.3.6 floyd算法

本质是一个DP，枚举中间点更新最短路径

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long maxn=2005;
const long long inf=0x7fffffff;
long long f[maxn][maxn];
long long n,m,s;
long long read()
{
	register long long num=0,f=1;
	register char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		num=num*10+ch-'0';
		ch=getchar();
	}
	return num*f;
}
//设f[i][j]表示从i到j的最短距离
//枚举中间点k,考虑松弛不等式
int main()
{
	long long x,y,z;
	n=read();m=read();s=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			f[i][j]=inf;
	for(int i=1;i<=n;i++) f[i][i]=0;
	for(long long i=1;i<=m;i++)
	{
		x=read();y=read();z=read();
		if(x==y) continue;
		f[x][y]=min(f[x][y],z);
	}
	for(long long k=1;k<=n;k++)
		for(long long i=1;i<=n;i++)
			for(long long j=1;j<=n;j++)
				if(f[i][k]!=inf&&f[k][j]!=inf)
					f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
	for(int i=1;i<=s;i++)
	{
		x=read();y=read();
		if(f[x][y]==inf) printf("impossible\n");
		else printf("%d\n",f[x][y]);
	}
	return 0;
}
```

### 3.4 最小生成树

$prim$算法的大致流程就是，维护所有其它点到当前最小生成树的距离，然后把距离最短的那个点加到最小生成树当中。听起来跟$dijkstra$算法贼像。而且它也可以使用堆优化

堆优化代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5005;
const int inf=0x7fffffff;
int g[maxn][maxn],ans,n,m;
bool vis[maxn];
struct node
{
	int nod;int val;
};
priority_queue<node> q;
bool operator < (const node &a,const node &b)
{
	return a.val>b.val;
}
void prim(int v0)
{
	q.push((node){v0,0});
	while(!q.empty())
	{
		node temp=q.top();q.pop();
		int u=temp.nod;if(vis[u]) continue;
		ans+=temp.val;vis[u]=true;
		for(int i=1;i<=n;i++)
		{
			if(!vis[i]&&g[u][i]!=inf)
			{
				q.push((node){i,g[u][i]});
			}
		}
	}
}
int main()
{
	int x,y,z;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) 
			g[i][j]=inf;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		g[x][y]=g[y][x]=min(g[x][y],z);
	}
	prim(1);
	for(int i=1;i<=n;i++)
		if(!vis[i])
		{
			printf("impossible\n");
			return 0;
		}
	printf("%d\n",ans);
	return 0;
}
```

### 3.4.2 Kruskal算法

与$prim$算法不同的是，$kruskal$算法从边入手，每次选取最短的边看能否加入最小生成树中，直到加到$n-1$条边为止，使用并查集查看要加入的这条边所连接的两个点是否已经连通

代码如下

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=200005;
const int maxm=200005;
struct node
{
	int next;
	int dis;
	int to;
}edge[maxm];
bool flag=true;
int fat[maxn],n,m,tot,ans;
void addedge(int from,int to,int dis)
{
	edge[++tot].next=from;
	edge[tot].to=to;
	edge[tot].dis=dis;
}
bool cmp(node x,node y)
{
	return x.dis<y.dis;
}
int father(int x)
{
	if(fat[x]==x) return x; 
	fat[x]=father(fat[x]);
	return fat[x]; 
}
void kruskal()
{
	int f1,f2,k=0;
	for(int i=1;i<=n;i++) fat[i]=i;
	for(int i=1;i<=m;i++)
	{
		f1=father(edge[i].next);
		f2=father(edge[i].to);
		if(f1!=f2)
		{
			ans+=edge[i].dis;
			fat[f1]=f2;
			k++;
			if(k==n-1) break;
		}
	}
    if(k<n-1) flag=false;
	return;   
}
int main()
{
	int x,y,z;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		addedge(x,y,z);
	}
	sort(edge+1,edge+m+1,cmp);
	kruskal();
	if(flag) printf("%d\n",ans);
	else printf("impossible\n");
	return 0;
}
```

### 二分图的判定

染色法，很简单，遍历的同时给点上色，如果一条边连的两个点颜色相同，那就肯定不是二分图

可以DFS也可以BFS

```cpp
#include<bits/stdc++.h>
#define il inline
using namespace std;
const int maxn=1e5+5;
int head[maxn],color[maxn],n,m,tot;
struct Edge
{
	int next;int to;
}edge[maxn];
queue<int> q;
il int read()
{
	int num=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		num=num*10+ch-'0';
		ch=getchar();
	}
	return num*f;
}
il void addedge(int from,int to)
{
	edge[++tot].next=head[from];
	edge[tot].to=to;
	head[from]=tot;
}
il bool bfs(int s)
{
	q.push(s);color[s]=1;
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(!color[v])
			{
				color[v]=3-color[u];
				q.push(v);
			}
			if(color[v]==color[u]) return false;
		}
	}
	return true;
}
int main()
{
	int x,y;
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		x=read();y=read();
		addedge(x,y);
		addedge(y,x);
	}
	for(int i=1;i<=n;i++)
		if(!color[i]&&!bfs(i)) 
		{
			printf("No\n");
			return 0;
		}
	printf("Yes\n");
	return 0;
}
```

### 3.4.2二分图的最大匹配

贪心地让匹配数最大化。

一句话概括：A男生找心仪的几个妹子配对，如果当前的这个妹子已经配对了，如果这个妹子的男朋友有其他备胎，那就让他找备胎。这个妹子跟A男生配对。没有备胎就换下一个心仪妹子

找备胎的过程刚好可以递归处理

代码如下

```cpp
#include<bits/stdc++.h>
#define il inline
using namespace std;
const int maxn=5e5+5;
int match[maxn],head[maxn];
int n1,n2,m,ans,tot;
bool vis[maxn];
struct Edge
{
	int next;int to;
}edge[maxn];
il int read()
{
	int num=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		num=num*10+ch-'0';
		ch=getchar();
	}
	return num*f;
}
il void addedge(int from,int to)
{
	edge[++tot].next=head[from];
	edge[tot].to=to;
	head[from]=tot;
}
bool find(int u)
{
	for(int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(vis[v]) continue;
		vis[v]=true;//暂时先占着这个妹子，方便搜索这个妹子当前的男朋友的备胎
		if(!match[v]||find(match[v]))
		{
			match[u]=v;
			return true;
		}
	}
	return false;
}
int main()
{
	int x,y;
	n1=read();n2=read();m=read();
	for(int i=1;i<=m;i++)
	{
		x=read();y=read();
		addedge(x,y);
	}
	for(int i=1;i<=n1;i++)
	{
		memset(vis,0,sizeof vis);
		if(find(i)) ans++;
	}
	printf("%d\n",ans);
	return 0;
}
```

