# Day5 状压DP

听数位DP其实已经有点劝退了，希望状压DP能够轻松一点吧。其实归根结底还是以前接触的少了，也懒，练得少了

老师先讲了几道很典的例题

### 例题一

现有$n*m$的一块地板，需要用1*2的砖块去铺满，中间不能留有空隙。问这样方案有多少种

比较典的一个状态设计是这样，设$dp[i][sta]$表示前$i$行填满对第$i+1$行的影响为状态$sta$时的方案总数

但是老师提出了一种新的状态设计$dp[x][y][sta]$表示该铺第$x$行，第$y$列的格子了，此时轮廓线上的$n$个点是否被占满的状态是$sta$，当时没有想通$sta$如何表示轮廓线，之后凭借回放老师的代码想通了,要考虑的是当前这一行以及上一行

代码如下

```cpp
void DP()
{
	dp[1][0][0]=1;
	for(int x=1;x<=m;x++)
		for(int y=0;y<n;y++)
			for(int sta=0;sta<(1<<n);sta++)
			if(dp[x][y][sta])
			{
				int nx=x,ny=n+1;
				if(ny==n) ny=0,nx++;
				//（x,y）已经被占用
				if((sta>>y&1)) dp[nx][ny][sta^(1<<y)]+=dp[x][y][sta];
				else
				{
					//竖着铺,将轮廓线占着
					dp[nx][ny][sta|(1<<y)]+=dp[x][y][sta]);
					//横着铺
					if(y+1<n&&(sta>>(y+1))&1==0)
						dp[nx][ny][sta|(1<<(y+1))]+=dp[x][y][sta];
				}
			}
}
```



### 例题二

N个点，M条边的一幅图，每个节点都至少访问一次，问最短路是多少

我的状压DP入门题，设$dp[sta][j]$表示访问状态为$sta$,且当前在第$j$个点时的最短路。

枚举转移点$k$

当状态合法时就有$dp[i][j]=min(dp[i^(1<<j)][k]+e[j][k]);$

```cpp
for(int i=1;i<1<<n;i++)
		for(int j=0;j<n;j++)
			if(i>>j&1)//判断状态是否合法
				for(int k=0;k<n;k++)
					if(i^(1<<j)>>k&1) 
						dp[i][j]=min(dp[i^(1<<j)][k]+e[j][k],dp[i][j]);
	printf("%d\n",dp[(1<<n)-1][n-1]);
```

### T1

$N*M$的矩阵，有的地方不能放棋子，问：最多能放多少个炮，互相攻击不到，每个炮可以打四个方向内距离自己为2以内的格子

跟N国王问题很像，考虑如何压缩状态，逐行地放置的话，那么每个炮都会影响到后面两行的状态

设$dp[i][sta1][sta2]$表示当前考虑到了第$i$行，当前行的状态为sta1,下一行的状态为sta2的最多炮兵数

$p[i][nsta1][nsta2]=max(p[i-1][sta1][sta2])$，然后要处理很多细节问题



很菜，调状压DP的很多细节都考虑不好，基本都是看题解写出来的。。。

待我多练一些位基础再回来补老师讲的这些课程
